<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! Instead, edit the notebook w/the location & name as this file. -->

# `@checkpoint`


<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [Introduction](#introduction)
- [Functional Overview](#functional-overview)
  - [Simple Example](#simple-example)
  - [Load Policies And Accessing Past Checkpoints.](#load-policies-and-accessing-past-checkpoints)
  - [Saving Checkpoints within Subprocesses.](#saving-checkpoints-within-subprocesses)
  - [Saving / Loading Checkpoints within a foreach](#saving--loading-checkpoints-within-a-foreach)
  - [Saving / Loading Checkpoints for Gang Scheduled `@parallel` steps](#saving--loading-checkpoints-for-gang-scheduled-parallel-steps)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


## Introduction 

Metaflow naturally allows passing state around between `@step`s via the means of [Data Artifacts](https://docs.metaflow.org/metaflow/client#accessing-data) (i.e. values set to `self`). This means that when user code in a @step completes execution, all the values set to `self` are automatically saved as a Data Artifact and those are accessible to the next `@step`s. Such persistence of state allows users to ["resume" code execution](https://docs.metaflow.org/metaflow/debugging#how-to-use-the-resume-command) from a particular `@step` in case the user code crashes for some reason. 

However there may be scenarios where a user's `@step` will run for a very long duration and there are no natural boundaries to breakup this function. In such cases, the user may want to save the state of the function periodically and if the `@step` crashes, then the desired behavior would be to resume execution from the last saved state. This can be particularly useful when users use an `@retry` decorator. 

The `@checkpoint` decorator provides this functionality by allowing users to save intermediate state during `@step` execution. For example, consider a scenario where a user is training a large deep learning model that takes several hours to train. The user may want to save the model weights periodically during training so that if the training crashes, they can resume from the last saved checkpoint rather than starting from scratch. The `@checkpoint` decorator provides this functionality by allowing users to save intermediate state during `@step` execution.
 
Another common use case is when processing large datasets in batches. Users may want to checkpoint after processing each batch so that if there's a failure, they can resume from the last successfully processed batch rather than reprocessing everything from the beginning.The `@checkpoint` decorator is particularly powerful when combined with `@retry` - if a step fails, it will retry from the last checkpoint rather than from the very beginning of the step. This can significantly reduce recovery time and resource usage when dealing with long-running computations.

## Functional Overview

The `@checkpoint` decorator provides a simple way to save and load checkpoints within your Metaflow steps. It's particularly useful for machine learning workflows where you need to save model states, handle failures, and resume training. This can also be useful for any other form of long-running computation where users want to save the state of the computation periodically so that it can be resumed later. 

The `@checkpoint` decorator injects a `checkpoint` object in Metaflow's `current` object. This `checkpoint` object provides the `save` method that can _save any state present on disk_. Incase the `@step` crashes and retries, this previously saved checkpoint will be loaded to a directory that is exposed via the `current.checkpoint.directory` property. All checkpoints saved are scoped to the `@step` they are created in. All checkpoints are saved under the execution's [namespace](https://docs.metaflow.org/scaling/tagging#namespaces). This also implies that what ever checkpoint gets reloaded in subsequent retries will be for the same `@step` and under the same namespace.


### Simple Example

Consider the below example. The `count_values` `@step` will keep incrementing a `counter` until it reaches a certain value. At the end of the `@step`, if the counter has not reached a threshold value then the `@step` will crash. A `@retry` decorator is also added to the `@step` to retry the function in case it crashes. The `@checkpoint` decorator is used to save the state of the counter during the iterations and if the `@step` crashes, the `current.checkpoint.directory` will be populated with the last saved checkpoint. The contents of the counter present in this directory are loaded if the checkpoint is loaded. If a checkpoint is loaded for a `@step`, the `current.checkpoint.is_loaded` property will be set to `True`. The info about the checkpoint will be accessible via the `current.checkpoint.info` property.

Calling `current.checkpoint.save()` will save the contents of the `current.checkpoint.directory` to the datastore. The return value of this method is a reference to the checkpoint that was created. This reference can be loaded in later steps or within the same step upon retries. The `save` method can even take the following optional arguments:
- `path` : A custom path to a directory/file that will be saved as a checkpoint 
- `metadata` : A dictionary of metadata that to be saved with the checkpoint
- `name` : A custom name for the checkpoint to distinguish between different checkpoints created during a step 
- `latest` : A boolean flag to indicate if this checkpoint should be marked as the latest checkpoint. This will be checkpoint that will be reloaded by default unless the user specifies different settings in the `@checkpoint` decorator.




```py title="temp_files/checkpoint_basic.py"
from metaflow import FlowSpec, current, step, retry, checkpoint
import os
import time 

MAX_RETRIES = 5

class CheckpointSimpleFlow(FlowSpec):

    continue_until = 15


    @checkpoint
    @retry(times=4)
    @step
    def count_values(self):
        counter = 0
        _file_path = os.path.join(
            current.checkpoint.directory, 
            "counter.txt"
        )
        if current.checkpoint.is_loaded and os.path.exists(_file_path):
            # Load the file written by a previous execution of the step
            checkpoint_info = current.checkpoint.info
            file = _read_file(_file_path)
            print("Loaded a checkpoint from pathspec %s, attempt %s" % (checkpoint_info.pathspec, checkpoint_info.attempt))
            print(
                "reading the counter value from the file",
                file,
            )
            counter = int(file)

        per_retry_range = 10
        for i in range(counter, counter + per_retry_range):
            counter = i
            _write_file(_file_path, str(i))
            # `current.checkpoint.save` will save everything in the
            # `current.checkpoint.directory`
            # Saving implies the objects are saved in the datastore
            # Saving a checkpoint will return a reference to the checkpoint
            self.final_checkpoint = current.checkpoint.save()
            time.sleep(0.1)
            
        print("Current value of counter", counter)
        if self.continue_until > counter:
            raise ValueError("retry")

        self.next(self.end)




```

<CodeOutputBlock lang="bash">

```
    ...

    ...

    ...

    ...

    ...

    ...

    ...
     [7453/count_values/47440 (pid 2203250)] Task is starting.
    ...

    ...
     [7453/count_values/47440 (pid 2203250)] Current value of counter 9
    ...

    ...
     [7453/count_values/47440 (pid 2203250)] <flow CheckpointSimpleFlow step count_values> failed:
    ...

    ...
     [7453/count_values/47440 (pid 2203250)] Internal error
     [7453/count_values/47440 (pid 2203250)] Traceback (most recent call last):
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/cli.py", line 1167, in main
     [7453/count_values/47440 (pid 2203250)] start(auto_envvar_prefix="METAFLOW", obj=state)
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/tracing/tracing_modules.py", line 111, in wrapper_func
     [7453/count_values/47440 (pid 2203250)] return func(args, kwargs)
     [7453/count_values/47440 (pid 2203250)] ^^^^^^^^^^^^^^^^^^^^^
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/_vendor/click/core.py", line 829, in __call__
     [7453/count_values/47440 (pid 2203250)] return self.main(args, kwargs)
    ...

    ...
     [7453/count_values/47440 (pid 2203250)] ^^^^^^^^^^^^^^^^^^^^^^^^^^
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/_vendor/click/core.py", line 782, in main
     [7453/count_values/47440 (pid 2203250)] rv = self.invoke(ctx)
     [7453/count_values/47440 (pid 2203250)] ^^^^^^^^^^^^^^^^
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/_vendor/click/core.py", line 1259, in invoke
     [7453/count_values/47440 (pid 2203250)] return _process_result(sub_ctx.command.invoke(sub_ctx))
     [7453/count_values/47440 (pid 2203250)] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/_vendor/click/core.py", line 1066, in invoke
     [7453/count_values/47440 (pid 2203250)] return ctx.invoke(self.callback, ctx.params)
     [7453/count_values/47440 (pid 2203250)] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/_vendor/click/core.py", line 610, in invoke
     [7453/count_values/47440 (pid 2203250)] return callback(args, kwargs)
     [7453/count_values/47440 (pid 2203250)] ^^^^^^^^^^^^^^^^^^^^^^^^^
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/_vendor/click/decorators.py", line 21, in new_func
     [7453/count_values/47440 (pid 2203250)] return f(get_current_context(), args, kwargs)
     [7453/count_values/47440 (pid 2203250)] ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/cli.py", line 469, in step
     [7453/count_values/47440 (pid 2203250)] task.run_step(
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/task.py", line 653, in run_step
     [7453/count_values/47440 (pid 2203250)] self._exec_step_function(step_func)
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow/metaflow/task.py", line 62, in _exec_step_function
     [7453/count_values/47440 (pid 2203250)] step_function()
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow-checkpoint/metaflow_extensions/obcheckpoint/plugins/machine_learning_utilities/checkpoints/decorator.py", line 592, in _wrapped_step_func
     [7453/count_values/47440 (pid 2203250)] return step_func(args, kwargs)
     [7453/count_values/47440 (pid 2203250)] ^^^^^^^^^^^^^^^^^^^^^^^^^^
     [7453/count_values/47440 (pid 2203250)] File "/home/ubuntu/metaflow-checkpoint-examples/documentation/checkpoint_deco/temp_files/checkpoint_basic.py", line 49, in count_values
     [7453/count_values/47440 (pid 2203250)] raise ValueError("retry")
     [7453/count_values/47440 (pid 2203250)] ValueError: retry
     [7453/count_values/47440 (pid 2203250)] 
    ...

    ...
     [7453/count_values/47440 (pid 2203250)] Task failed.
    ...

    ...
     [7453/count_values/47440 (pid 2204262)] Task is starting (retry).
    ...

    ...
     [7453/count_values/47440 (pid 2204262)] [@checkpoint] Loading the following checkpoint:
    ...

    ...
     [7453/count_values/47440 (pid 2204262)] [pathspec] CheckpointSimpleFlow/7453/count_values/47440
     [7453/count_values/47440 (pid 2204262)] [key] mf.checkpoints/checkpoints/artifacts/CheckpointSimpleFlow/count_values/26ec4b03ee0e/6ed314b634c7/1e2df857.0.mfchckpt.9
     [7453/count_values/47440 (pid 2204262)] [created on] 2024-12-11T06:09:36.055073
     [7453/count_values/47440 (pid 2204262)] [url] s3://obp-475b0e-metaflow/metaflow/mf.checkpoints/checkpoints/artifacts/CheckpointSimpleFlow/count_values/26ec4b03ee0e/6ed314b634c7/1e2df857.0.mfchckpt.9
     [7453/count_values/47440 (pid 2204262)] Loaded a checkpoint from pathspec CheckpointSimpleFlow/7453/count_values/47440, attempt 0
    ...

    ...
     [7453/count_values/47440 (pid 2204262)] reading the counter value from the file 9
     [7453/count_values/47440 (pid 2204262)] Current value of counter 18
    ...

    ...
     [7453/count_values/47440 (pid 2204262)] Task finished successfully.
    ...

    ...

    ...

    ...
```

</CodeOutputBlock>

### Load Policies And Accessing Past Checkpoints. 

The `@checkpoint` decorator provides a `load_policy` argument which alters the checkpoint loading behavior in Metaflow. The `load_policy` argument can take the following values:
- `fresh` (default): The latest checkpoint created within the task will be loaded. This means that no checkpoint will ever be loaded at the start of the task execution on the very first attempt. Upon subsequent retries, the latest checkpoint will be loaded. 
- `eager` : The latest available checkpoint associated with a step (which might have even been created in a previous execution) will be loaded. 
- `none`: No checkpoint will ever be loaded. It's left to the user to explicitly choose/load a checkpoint within the user code. Users can select a checkpoint within user code by accessing the `current.checkpoint.list` method and the load the checkpoint using the `current.checkpoint.load` method.

The `current.checkpoint` object also provides a `list` method. The `current.checkpoint.list` method returns a list of checkpoints associated with the current step. All checkpoints listed will be scoped to the current step and the current task's namespace. The `list` method can take several optional arguments such as: 
- `name`: A string to filter checkpoints by name
- `task`: A Metaflow pathspec string or [Metaflow Task object](https://docs.metaflow.org/api/client#task) to filter checkpoints
- `attempt`: An integer to filter checkpoints by attempt number
- `within_task` : A boolean flag to indicate if the checkpoints should be filtered by the currently running task or for all previous tasks of the step.


### Saving Checkpoints within Subprocesses.
[TODO]

### Saving / Loading Checkpoints within a foreach
[TODO]

### Saving / Loading Checkpoints for Gang Scheduled `@parallel` steps
[TODO]


